// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/mmildd_s/app/ent/certificate"
	"github.com/mmildd_s/app/ent/coveredperson"
	"github.com/mmildd_s/app/ent/fund"
	"github.com/mmildd_s/app/ent/patient"
	"github.com/mmildd_s/app/ent/schemetype"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCertificate   = "Certificate"
	TypeCoveredPerson = "CoveredPerson"
	TypeFund          = "Fund"
	TypePatient       = "Patient"
	TypeSchemeType    = "SchemeType"
)

// CertificateMutation represents an operation that mutate the Certificates
// nodes in the graph.
type CertificateMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	_Certificate_Name                 *string
	clearedFields                     map[string]struct{}
	_Certificate_CoveredPerson        map[int]struct{}
	removed_Certificate_CoveredPerson map[int]struct{}
	done                              bool
	oldValue                          func(context.Context) (*Certificate, error)
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows to manage the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for $n.Name.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the id field of the mutation.
func withCertificateID(id int) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CertificateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCertificateName sets the Certificate_Name field.
func (m *CertificateMutation) SetCertificateName(s string) {
	m._Certificate_Name = &s
}

// CertificateName returns the Certificate_Name value in the mutation.
func (m *CertificateMutation) CertificateName() (r string, exists bool) {
	v := m._Certificate_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateName returns the old Certificate_Name value of the Certificate.
// If the Certificate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CertificateMutation) OldCertificateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCertificateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCertificateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateName: %w", err)
	}
	return oldValue.CertificateName, nil
}

// ResetCertificateName reset all changes of the "Certificate_Name" field.
func (m *CertificateMutation) ResetCertificateName() {
	m._Certificate_Name = nil
}

// AddCertificateCoveredPersonIDs adds the Certificate_CoveredPerson edge to CoveredPerson by ids.
func (m *CertificateMutation) AddCertificateCoveredPersonIDs(ids ...int) {
	if m._Certificate_CoveredPerson == nil {
		m._Certificate_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Certificate_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveCertificateCoveredPersonIDs removes the Certificate_CoveredPerson edge to CoveredPerson by ids.
func (m *CertificateMutation) RemoveCertificateCoveredPersonIDs(ids ...int) {
	if m.removed_Certificate_CoveredPerson == nil {
		m.removed_Certificate_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Certificate_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedCertificateCoveredPerson returns the removed ids of Certificate_CoveredPerson.
func (m *CertificateMutation) RemovedCertificateCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Certificate_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// CertificateCoveredPersonIDs returns the Certificate_CoveredPerson ids in the mutation.
func (m *CertificateMutation) CertificateCoveredPersonIDs() (ids []int) {
	for id := range m._Certificate_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetCertificateCoveredPerson reset all changes of the "Certificate_CoveredPerson" edge.
func (m *CertificateMutation) ResetCertificateCoveredPerson() {
	m._Certificate_CoveredPerson = nil
	m.removed_Certificate_CoveredPerson = nil
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Certificate_Name != nil {
		fields = append(fields, certificate.FieldCertificateName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldCertificateName:
		return m.CertificateName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldCertificateName:
		return m.OldCertificateName(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldCertificateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateName(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CertificateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldCertificateName:
		m.ResetCertificateName()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Certificate_CoveredPerson != nil {
		edges = append(edges, certificate.EdgeCertificateCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Certificate_CoveredPerson))
		for id := range m._Certificate_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Certificate_CoveredPerson != nil {
		edges = append(edges, certificate.EdgeCertificateCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Certificate_CoveredPerson))
		for id := range m.removed_Certificate_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		m.ResetCertificateCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// CoveredPersonMutation represents an operation that mutate the CoveredPersons
// nodes in the graph.
type CoveredPersonMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	clearedFields       map[string]struct{}
	_Patient            *int
	cleared_Patient     bool
	_SchemeType         *int
	cleared_SchemeType  bool
	_Fund               *int
	cleared_Fund        bool
	_Certificate        *int
	cleared_Certificate bool
	done                bool
	oldValue            func(context.Context) (*CoveredPerson, error)
}

var _ ent.Mutation = (*CoveredPersonMutation)(nil)

// coveredpersonOption allows to manage the mutation configuration using functional options.
type coveredpersonOption func(*CoveredPersonMutation)

// newCoveredPersonMutation creates new mutation for $n.Name.
func newCoveredPersonMutation(c config, op Op, opts ...coveredpersonOption) *CoveredPersonMutation {
	m := &CoveredPersonMutation{
		config:        c,
		op:            op,
		typ:           TypeCoveredPerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoveredPersonID sets the id field of the mutation.
func withCoveredPersonID(id int) coveredpersonOption {
	return func(m *CoveredPersonMutation) {
		var (
			err   error
			once  sync.Once
			value *CoveredPerson
		)
		m.oldValue = func(ctx context.Context) (*CoveredPerson, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoveredPerson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoveredPerson sets the old CoveredPerson of the mutation.
func withCoveredPerson(node *CoveredPerson) coveredpersonOption {
	return func(m *CoveredPersonMutation) {
		m.oldValue = func(context.Context) (*CoveredPerson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoveredPersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoveredPersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CoveredPersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientID sets the Patient edge to Patient by id.
func (m *CoveredPersonMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the Patient edge to Patient.
func (m *CoveredPersonMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the edge Patient was cleared.
func (m *CoveredPersonMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the Patient id in the mutation.
func (m *CoveredPersonMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the Patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "Patient" edge.
func (m *CoveredPersonMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetSchemeTypeID sets the SchemeType edge to SchemeType by id.
func (m *CoveredPersonMutation) SetSchemeTypeID(id int) {
	m._SchemeType = &id
}

// ClearSchemeType clears the SchemeType edge to SchemeType.
func (m *CoveredPersonMutation) ClearSchemeType() {
	m.cleared_SchemeType = true
}

// SchemeTypeCleared returns if the edge SchemeType was cleared.
func (m *CoveredPersonMutation) SchemeTypeCleared() bool {
	return m.cleared_SchemeType
}

// SchemeTypeID returns the SchemeType id in the mutation.
func (m *CoveredPersonMutation) SchemeTypeID() (id int, exists bool) {
	if m._SchemeType != nil {
		return *m._SchemeType, true
	}
	return
}

// SchemeTypeIDs returns the SchemeType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SchemeTypeID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) SchemeTypeIDs() (ids []int) {
	if id := m._SchemeType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchemeType reset all changes of the "SchemeType" edge.
func (m *CoveredPersonMutation) ResetSchemeType() {
	m._SchemeType = nil
	m.cleared_SchemeType = false
}

// SetFundID sets the Fund edge to Fund by id.
func (m *CoveredPersonMutation) SetFundID(id int) {
	m._Fund = &id
}

// ClearFund clears the Fund edge to Fund.
func (m *CoveredPersonMutation) ClearFund() {
	m.cleared_Fund = true
}

// FundCleared returns if the edge Fund was cleared.
func (m *CoveredPersonMutation) FundCleared() bool {
	return m.cleared_Fund
}

// FundID returns the Fund id in the mutation.
func (m *CoveredPersonMutation) FundID() (id int, exists bool) {
	if m._Fund != nil {
		return *m._Fund, true
	}
	return
}

// FundIDs returns the Fund ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FundID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) FundIDs() (ids []int) {
	if id := m._Fund; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFund reset all changes of the "Fund" edge.
func (m *CoveredPersonMutation) ResetFund() {
	m._Fund = nil
	m.cleared_Fund = false
}

// SetCertificateID sets the Certificate edge to Certificate by id.
func (m *CoveredPersonMutation) SetCertificateID(id int) {
	m._Certificate = &id
}

// ClearCertificate clears the Certificate edge to Certificate.
func (m *CoveredPersonMutation) ClearCertificate() {
	m.cleared_Certificate = true
}

// CertificateCleared returns if the edge Certificate was cleared.
func (m *CoveredPersonMutation) CertificateCleared() bool {
	return m.cleared_Certificate
}

// CertificateID returns the Certificate id in the mutation.
func (m *CoveredPersonMutation) CertificateID() (id int, exists bool) {
	if m._Certificate != nil {
		return *m._Certificate, true
	}
	return
}

// CertificateIDs returns the Certificate ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CertificateID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) CertificateIDs() (ids []int) {
	if id := m._Certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertificate reset all changes of the "Certificate" edge.
func (m *CoveredPersonMutation) ResetCertificate() {
	m._Certificate = nil
	m.cleared_Certificate = false
}

// Op returns the operation name.
func (m *CoveredPersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CoveredPerson).
func (m *CoveredPersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CoveredPersonMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CoveredPersonMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CoveredPersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CoveredPerson field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CoveredPersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CoveredPerson field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CoveredPersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CoveredPersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CoveredPersonMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CoveredPerson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CoveredPersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CoveredPersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoveredPersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CoveredPerson nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CoveredPersonMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CoveredPerson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CoveredPersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Patient != nil {
		edges = append(edges, coveredperson.EdgePatient)
	}
	if m._SchemeType != nil {
		edges = append(edges, coveredperson.EdgeSchemeType)
	}
	if m._Fund != nil {
		edges = append(edges, coveredperson.EdgeFund)
	}
	if m._Certificate != nil {
		edges = append(edges, coveredperson.EdgeCertificate)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CoveredPersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coveredperson.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeSchemeType:
		if id := m._SchemeType; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeFund:
		if id := m._Fund; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeCertificate:
		if id := m._Certificate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CoveredPersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CoveredPersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CoveredPersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Patient {
		edges = append(edges, coveredperson.EdgePatient)
	}
	if m.cleared_SchemeType {
		edges = append(edges, coveredperson.EdgeSchemeType)
	}
	if m.cleared_Fund {
		edges = append(edges, coveredperson.EdgeFund)
	}
	if m.cleared_Certificate {
		edges = append(edges, coveredperson.EdgeCertificate)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CoveredPersonMutation) EdgeCleared(name string) bool {
	switch name {
	case coveredperson.EdgePatient:
		return m.cleared_Patient
	case coveredperson.EdgeSchemeType:
		return m.cleared_SchemeType
	case coveredperson.EdgeFund:
		return m.cleared_Fund
	case coveredperson.EdgeCertificate:
		return m.cleared_Certificate
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CoveredPersonMutation) ClearEdge(name string) error {
	switch name {
	case coveredperson.EdgePatient:
		m.ClearPatient()
		return nil
	case coveredperson.EdgeSchemeType:
		m.ClearSchemeType()
		return nil
	case coveredperson.EdgeFund:
		m.ClearFund()
		return nil
	case coveredperson.EdgeCertificate:
		m.ClearCertificate()
		return nil
	}
	return fmt.Errorf("unknown CoveredPerson unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CoveredPersonMutation) ResetEdge(name string) error {
	switch name {
	case coveredperson.EdgePatient:
		m.ResetPatient()
		return nil
	case coveredperson.EdgeSchemeType:
		m.ResetSchemeType()
		return nil
	case coveredperson.EdgeFund:
		m.ResetFund()
		return nil
	case coveredperson.EdgeCertificate:
		m.ResetCertificate()
		return nil
	}
	return fmt.Errorf("unknown CoveredPerson edge %s", name)
}

// FundMutation represents an operation that mutate the Funds
// nodes in the graph.
type FundMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Fund_Name                 *string
	clearedFields              map[string]struct{}
	_Fund_CoveredPerson        map[int]struct{}
	removed_Fund_CoveredPerson map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Fund, error)
}

var _ ent.Mutation = (*FundMutation)(nil)

// fundOption allows to manage the mutation configuration using functional options.
type fundOption func(*FundMutation)

// newFundMutation creates new mutation for $n.Name.
func newFundMutation(c config, op Op, opts ...fundOption) *FundMutation {
	m := &FundMutation{
		config:        c,
		op:            op,
		typ:           TypeFund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFundID sets the id field of the mutation.
func withFundID(id int) fundOption {
	return func(m *FundMutation) {
		var (
			err   error
			once  sync.Once
			value *Fund
		)
		m.oldValue = func(ctx context.Context) (*Fund, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFund sets the old Fund of the mutation.
func withFund(node *Fund) fundOption {
	return func(m *FundMutation) {
		m.oldValue = func(context.Context) (*Fund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FundMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFundName sets the Fund_Name field.
func (m *FundMutation) SetFundName(s string) {
	m._Fund_Name = &s
}

// FundName returns the Fund_Name value in the mutation.
func (m *FundMutation) FundName() (r string, exists bool) {
	v := m._Fund_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldFundName returns the old Fund_Name value of the Fund.
// If the Fund object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FundMutation) OldFundName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFundName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFundName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundName: %w", err)
	}
	return oldValue.FundName, nil
}

// ResetFundName reset all changes of the "Fund_Name" field.
func (m *FundMutation) ResetFundName() {
	m._Fund_Name = nil
}

// AddFundCoveredPersonIDs adds the Fund_CoveredPerson edge to CoveredPerson by ids.
func (m *FundMutation) AddFundCoveredPersonIDs(ids ...int) {
	if m._Fund_CoveredPerson == nil {
		m._Fund_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Fund_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveFundCoveredPersonIDs removes the Fund_CoveredPerson edge to CoveredPerson by ids.
func (m *FundMutation) RemoveFundCoveredPersonIDs(ids ...int) {
	if m.removed_Fund_CoveredPerson == nil {
		m.removed_Fund_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Fund_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedFundCoveredPerson returns the removed ids of Fund_CoveredPerson.
func (m *FundMutation) RemovedFundCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Fund_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// FundCoveredPersonIDs returns the Fund_CoveredPerson ids in the mutation.
func (m *FundMutation) FundCoveredPersonIDs() (ids []int) {
	for id := range m._Fund_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetFundCoveredPerson reset all changes of the "Fund_CoveredPerson" edge.
func (m *FundMutation) ResetFundCoveredPerson() {
	m._Fund_CoveredPerson = nil
	m.removed_Fund_CoveredPerson = nil
}

// Op returns the operation name.
func (m *FundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Fund).
func (m *FundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FundMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Fund_Name != nil {
		fields = append(fields, fund.FieldFundName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fund.FieldFundName:
		return m.FundName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fund.FieldFundName:
		return m.OldFundName(ctx)
	}
	return nil, fmt.Errorf("unknown Fund field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fund.FieldFundName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundName(v)
		return nil
	}
	return fmt.Errorf("unknown Fund field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FundMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Fund nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FundMutation) ResetField(name string) error {
	switch name {
	case fund.FieldFundName:
		m.ResetFundName()
		return nil
	}
	return fmt.Errorf("unknown Fund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Fund_CoveredPerson != nil {
		edges = append(edges, fund.EdgeFundCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fund.EdgeFundCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Fund_CoveredPerson))
		for id := range m._Fund_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Fund_CoveredPerson != nil {
		edges = append(edges, fund.EdgeFundCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fund.EdgeFundCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Fund_CoveredPerson))
		for id := range m.removed_Fund_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FundMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Fund unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FundMutation) ResetEdge(name string) error {
	switch name {
	case fund.EdgeFundCoveredPerson:
		m.ResetFundCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown Fund edge %s", name)
}

// PatientMutation represents an operation that mutate the Patients
// nodes in the graph.
type PatientMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	_Patient_Name                 *string
	_Patient_Age                  *string
	_Patient_Weight               *string
	_Patient_Height               *string
	_Patient_Prefix               *string
	_Patient_Gender               *string
	_Patient_Blood                *string
	clearedFields                 map[string]struct{}
	_Patient_CoveredPerson        map[int]struct{}
	removed_Patient_CoveredPerson map[int]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Patient, error)
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows to manage the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for $n.Name.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the id field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientName sets the Patient_Name field.
func (m *PatientMutation) SetPatientName(s string) {
	m._Patient_Name = &s
}

// PatientName returns the Patient_Name value in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m._Patient_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old Patient_Name value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName reset all changes of the "Patient_Name" field.
func (m *PatientMutation) ResetPatientName() {
	m._Patient_Name = nil
}

// SetPatientAge sets the Patient_Age field.
func (m *PatientMutation) SetPatientAge(s string) {
	m._Patient_Age = &s
}

// PatientAge returns the Patient_Age value in the mutation.
func (m *PatientMutation) PatientAge() (r string, exists bool) {
	v := m._Patient_Age
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientAge returns the old Patient_Age value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientAge: %w", err)
	}
	return oldValue.PatientAge, nil
}

// ResetPatientAge reset all changes of the "Patient_Age" field.
func (m *PatientMutation) ResetPatientAge() {
	m._Patient_Age = nil
}

// SetPatientWeight sets the Patient_Weight field.
func (m *PatientMutation) SetPatientWeight(s string) {
	m._Patient_Weight = &s
}

// PatientWeight returns the Patient_Weight value in the mutation.
func (m *PatientMutation) PatientWeight() (r string, exists bool) {
	v := m._Patient_Weight
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientWeight returns the old Patient_Weight value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientWeight: %w", err)
	}
	return oldValue.PatientWeight, nil
}

// ResetPatientWeight reset all changes of the "Patient_Weight" field.
func (m *PatientMutation) ResetPatientWeight() {
	m._Patient_Weight = nil
}

// SetPatientHeight sets the Patient_Height field.
func (m *PatientMutation) SetPatientHeight(s string) {
	m._Patient_Height = &s
}

// PatientHeight returns the Patient_Height value in the mutation.
func (m *PatientMutation) PatientHeight() (r string, exists bool) {
	v := m._Patient_Height
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientHeight returns the old Patient_Height value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientHeight: %w", err)
	}
	return oldValue.PatientHeight, nil
}

// ResetPatientHeight reset all changes of the "Patient_Height" field.
func (m *PatientMutation) ResetPatientHeight() {
	m._Patient_Height = nil
}

// SetPatientPrefix sets the Patient_Prefix field.
func (m *PatientMutation) SetPatientPrefix(s string) {
	m._Patient_Prefix = &s
}

// PatientPrefix returns the Patient_Prefix value in the mutation.
func (m *PatientMutation) PatientPrefix() (r string, exists bool) {
	v := m._Patient_Prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientPrefix returns the old Patient_Prefix value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientPrefix is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientPrefix: %w", err)
	}
	return oldValue.PatientPrefix, nil
}

// ResetPatientPrefix reset all changes of the "Patient_Prefix" field.
func (m *PatientMutation) ResetPatientPrefix() {
	m._Patient_Prefix = nil
}

// SetPatientGender sets the Patient_Gender field.
func (m *PatientMutation) SetPatientGender(s string) {
	m._Patient_Gender = &s
}

// PatientGender returns the Patient_Gender value in the mutation.
func (m *PatientMutation) PatientGender() (r string, exists bool) {
	v := m._Patient_Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientGender returns the old Patient_Gender value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientGender: %w", err)
	}
	return oldValue.PatientGender, nil
}

// ResetPatientGender reset all changes of the "Patient_Gender" field.
func (m *PatientMutation) ResetPatientGender() {
	m._Patient_Gender = nil
}

// SetPatientBlood sets the Patient_Blood field.
func (m *PatientMutation) SetPatientBlood(s string) {
	m._Patient_Blood = &s
}

// PatientBlood returns the Patient_Blood value in the mutation.
func (m *PatientMutation) PatientBlood() (r string, exists bool) {
	v := m._Patient_Blood
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientBlood returns the old Patient_Blood value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientBlood(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientBlood is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientBlood requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientBlood: %w", err)
	}
	return oldValue.PatientBlood, nil
}

// ResetPatientBlood reset all changes of the "Patient_Blood" field.
func (m *PatientMutation) ResetPatientBlood() {
	m._Patient_Blood = nil
}

// AddPatientCoveredPersonIDs adds the Patient_CoveredPerson edge to CoveredPerson by ids.
func (m *PatientMutation) AddPatientCoveredPersonIDs(ids ...int) {
	if m._Patient_CoveredPerson == nil {
		m._Patient_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Patient_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovePatientCoveredPersonIDs removes the Patient_CoveredPerson edge to CoveredPerson by ids.
func (m *PatientMutation) RemovePatientCoveredPersonIDs(ids ...int) {
	if m.removed_Patient_CoveredPerson == nil {
		m.removed_Patient_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Patient_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedPatientCoveredPerson returns the removed ids of Patient_CoveredPerson.
func (m *PatientMutation) RemovedPatientCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Patient_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// PatientCoveredPersonIDs returns the Patient_CoveredPerson ids in the mutation.
func (m *PatientMutation) PatientCoveredPersonIDs() (ids []int) {
	for id := range m._Patient_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetPatientCoveredPerson reset all changes of the "Patient_CoveredPerson" edge.
func (m *PatientMutation) ResetPatientCoveredPerson() {
	m._Patient_CoveredPerson = nil
	m.removed_Patient_CoveredPerson = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Patient_Name != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m._Patient_Age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	if m._Patient_Weight != nil {
		fields = append(fields, patient.FieldPatientWeight)
	}
	if m._Patient_Height != nil {
		fields = append(fields, patient.FieldPatientHeight)
	}
	if m._Patient_Prefix != nil {
		fields = append(fields, patient.FieldPatientPrefix)
	}
	if m._Patient_Gender != nil {
		fields = append(fields, patient.FieldPatientGender)
	}
	if m._Patient_Blood != nil {
		fields = append(fields, patient.FieldPatientBlood)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldPatientAge:
		return m.PatientAge()
	case patient.FieldPatientWeight:
		return m.PatientWeight()
	case patient.FieldPatientHeight:
		return m.PatientHeight()
	case patient.FieldPatientPrefix:
		return m.PatientPrefix()
	case patient.FieldPatientGender:
		return m.PatientGender()
	case patient.FieldPatientBlood:
		return m.PatientBlood()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldPatientAge:
		return m.OldPatientAge(ctx)
	case patient.FieldPatientWeight:
		return m.OldPatientWeight(ctx)
	case patient.FieldPatientHeight:
		return m.OldPatientHeight(ctx)
	case patient.FieldPatientPrefix:
		return m.OldPatientPrefix(ctx)
	case patient.FieldPatientGender:
		return m.OldPatientGender(ctx)
	case patient.FieldPatientBlood:
		return m.OldPatientBlood(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldPatientAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientAge(v)
		return nil
	case patient.FieldPatientWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientWeight(v)
		return nil
	case patient.FieldPatientHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientHeight(v)
		return nil
	case patient.FieldPatientPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientPrefix(v)
		return nil
	case patient.FieldPatientGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientGender(v)
		return nil
	case patient.FieldPatientBlood:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientBlood(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldPatientAge:
		m.ResetPatientAge()
		return nil
	case patient.FieldPatientWeight:
		m.ResetPatientWeight()
		return nil
	case patient.FieldPatientHeight:
		m.ResetPatientHeight()
		return nil
	case patient.FieldPatientPrefix:
		m.ResetPatientPrefix()
		return nil
	case patient.FieldPatientGender:
		m.ResetPatientGender()
		return nil
	case patient.FieldPatientBlood:
		m.ResetPatientBlood()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Patient_CoveredPerson != nil {
		edges = append(edges, patient.EdgePatientCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePatientCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Patient_CoveredPerson))
		for id := range m._Patient_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Patient_CoveredPerson != nil {
		edges = append(edges, patient.EdgePatientCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePatientCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Patient_CoveredPerson))
		for id := range m.removed_Patient_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgePatientCoveredPerson:
		m.ResetPatientCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// SchemeTypeMutation represents an operation that mutate the SchemeTypes
// nodes in the graph.
type SchemeTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	_SchemeType_Name                 *string
	clearedFields                    map[string]struct{}
	_SchemeType_CoveredPerson        map[int]struct{}
	removed_SchemeType_CoveredPerson map[int]struct{}
	done                             bool
	oldValue                         func(context.Context) (*SchemeType, error)
}

var _ ent.Mutation = (*SchemeTypeMutation)(nil)

// schemetypeOption allows to manage the mutation configuration using functional options.
type schemetypeOption func(*SchemeTypeMutation)

// newSchemeTypeMutation creates new mutation for $n.Name.
func newSchemeTypeMutation(c config, op Op, opts ...schemetypeOption) *SchemeTypeMutation {
	m := &SchemeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemeTypeID sets the id field of the mutation.
func withSchemeTypeID(id int) schemetypeOption {
	return func(m *SchemeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemeType
		)
		m.oldValue = func(ctx context.Context) (*SchemeType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemeType sets the old SchemeType of the mutation.
func withSchemeType(node *SchemeType) schemetypeOption {
	return func(m *SchemeTypeMutation) {
		m.oldValue = func(context.Context) (*SchemeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SchemeTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSchemeTypeName sets the SchemeType_Name field.
func (m *SchemeTypeMutation) SetSchemeTypeName(s string) {
	m._SchemeType_Name = &s
}

// SchemeTypeName returns the SchemeType_Name value in the mutation.
func (m *SchemeTypeMutation) SchemeTypeName() (r string, exists bool) {
	v := m._SchemeType_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemeTypeName returns the old SchemeType_Name value of the SchemeType.
// If the SchemeType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SchemeTypeMutation) OldSchemeTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchemeTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchemeTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemeTypeName: %w", err)
	}
	return oldValue.SchemeTypeName, nil
}

// ResetSchemeTypeName reset all changes of the "SchemeType_Name" field.
func (m *SchemeTypeMutation) ResetSchemeTypeName() {
	m._SchemeType_Name = nil
}

// AddSchemeTypeCoveredPersonIDs adds the SchemeType_CoveredPerson edge to CoveredPerson by ids.
func (m *SchemeTypeMutation) AddSchemeTypeCoveredPersonIDs(ids ...int) {
	if m._SchemeType_CoveredPerson == nil {
		m._SchemeType_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._SchemeType_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveSchemeTypeCoveredPersonIDs removes the SchemeType_CoveredPerson edge to CoveredPerson by ids.
func (m *SchemeTypeMutation) RemoveSchemeTypeCoveredPersonIDs(ids ...int) {
	if m.removed_SchemeType_CoveredPerson == nil {
		m.removed_SchemeType_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SchemeType_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedSchemeTypeCoveredPerson returns the removed ids of SchemeType_CoveredPerson.
func (m *SchemeTypeMutation) RemovedSchemeTypeCoveredPersonIDs() (ids []int) {
	for id := range m.removed_SchemeType_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// SchemeTypeCoveredPersonIDs returns the SchemeType_CoveredPerson ids in the mutation.
func (m *SchemeTypeMutation) SchemeTypeCoveredPersonIDs() (ids []int) {
	for id := range m._SchemeType_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetSchemeTypeCoveredPerson reset all changes of the "SchemeType_CoveredPerson" edge.
func (m *SchemeTypeMutation) ResetSchemeTypeCoveredPerson() {
	m._SchemeType_CoveredPerson = nil
	m.removed_SchemeType_CoveredPerson = nil
}

// Op returns the operation name.
func (m *SchemeTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SchemeType).
func (m *SchemeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SchemeTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._SchemeType_Name != nil {
		fields = append(fields, schemetype.FieldSchemeTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SchemeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemetype.FieldSchemeTypeName:
		return m.SchemeTypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SchemeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemetype.FieldSchemeTypeName:
		return m.OldSchemeTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown SchemeType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SchemeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemetype.FieldSchemeTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemeTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown SchemeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SchemeTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SchemeTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SchemeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SchemeTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SchemeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemeTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SchemeType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SchemeTypeMutation) ResetField(name string) error {
	switch name {
	case schemetype.FieldSchemeTypeName:
		m.ResetSchemeTypeName()
		return nil
	}
	return fmt.Errorf("unknown SchemeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SchemeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._SchemeType_CoveredPerson != nil {
		edges = append(edges, schemetype.EdgeSchemeTypeCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SchemeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		ids := make([]ent.Value, 0, len(m._SchemeType_CoveredPerson))
		for id := range m._SchemeType_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SchemeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_SchemeType_CoveredPerson != nil {
		edges = append(edges, schemetype.EdgeSchemeTypeCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SchemeTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_SchemeType_CoveredPerson))
		for id := range m.removed_SchemeType_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SchemeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SchemeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SchemeTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemeType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SchemeTypeMutation) ResetEdge(name string) error {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		m.ResetSchemeTypeCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown SchemeType edge %s", name)
}
